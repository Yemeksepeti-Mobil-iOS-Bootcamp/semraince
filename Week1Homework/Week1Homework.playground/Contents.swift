import UIKit
//MARK: - Day 1
/*
Question 1
 Elimizde sadece harflerden oluşan (noktalama işareti veya sayılar yok) uzun karakterler olsun. Bu karekterlerin içinde bazı hafrflerin tekrar edeceğini düşünün. Mesela 'a ' harfi 20 farklı yerde geçiyor. Bir fonksiyon ile verilen parametre değerine eşit ve daha fazla bulunan harfler silinecektir. Sonra geriye kalan string ekrana yazdırılacaktır. Not boşluklar sayılmayacak:)
 
 Örnek string: "aaba kouq bux"
 Tekrar sayısı 2 verildiğinde : a,b,u silinmeli ve ekrana "koq x" yazmalı
 Tekrar sayısı 3 verildiğinde : a silinmeli ve ekrana "b kouq bux"
 tekrar sayısı 4 verildiğinde  :  hiç bir harf silinmemeli aynı stringi yazmalı
 
 Not: String ve tekrar sayısını parametre olarak alsın. func (myString, count)
 */
func removeRepeatedCharacters(from myString: String, by count: Int) -> Void{
    var characterOccurences = [Character: Int]();
    for char in myString {
        characterOccurences[char] = (characterOccurences[char] ??  0) + 1 ;
    }
    
    var textWithUniqueChars = myString;
    
    for (char, occurence) in characterOccurences {
        if occurence >= count {
            textWithUniqueChars = textWithUniqueChars.replacingOccurrences(of: String(char), with: "");
        }
    }
    print("\"" + textWithUniqueChars + "\"");
}
print("Day 1 - Q1")
let repeatedString = "aaba kouq bux";
removeRepeatedCharacters(from: repeatedString, by: 2);

/*
 Question 2
 Elimizde uzun bir cümle olsun, Bazı kelimeler tekrar edecek bir cümle düşünün. İstediğimiz ise, hangi kelimeden kaç tane kullanıldığını bulmanız.
 string = "merhaba nasılsınız . iyiyim siz nasılsınız . bende iyiyim. "
 */

func findNumberOfOccurrencesWords(from text: String) -> [String: Int]{
    let cleanedTextArray = text.trimTrailingPunctuation().components(separatedBy: .punctuationCharacters).joined().replacingOccurrences(of: "[\\s\\s+]+\\s*", with: " ", options: .regularExpression, range: nil).components(separatedBy: " ")
    var wordOccurences = [String: Int]();
    for (word) in cleanedTextArray {
        wordOccurences[word] = (wordOccurences[word] ??  0) + 1 ;
    }
    return wordOccurences;
    
}

extension String {
    func trimTrailingPunctuation() -> String {
        return self.trimmingCharacters(in: .whitespacesAndNewlines)
                    .trimmingCharacters(in: .punctuationCharacters)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
let text = "merhaba nasılsınız . iyiyim siz nasılsınız . bende iyiyim. "
let numberOfWords = findNumberOfOccurrencesWords(from: text);
print("\nDay 1 - Q2")
print(numberOfWords);

//MARK: - Day 2
/*
 Problem 1
 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
 Find the sum of all the multiples of 3 or 5 below 1000.
 */
func sumOfNumbersDividedByThreeOrFive()->Int{
    let upperBound = 1000;
    let upperBoundFor3 = upperBound / 3;
    let upperBoundFor5 = upperBound / 5;
    let upperBoundFor15 = upperBound / 15;
    //Formula: S_n = n/2*( a_1 + a_n)
    
    let sumForDividedBy3 = (upperBoundFor3 * 3 * (upperBoundFor3 + 1)) / 2 ;
    let sumForDividedBy5 = (upperBoundFor5 * 5 * (upperBoundFor5 + 1)) / 2 ;
    let sumForDividedBy15 = (upperBoundFor15 * 15 * (upperBoundFor15 + 1)) / 2 ;
    
    return (sumForDividedBy3 + sumForDividedBy5 - sumForDividedBy15)
    
    
}
print("\nDay 2 - Q1")
print(sumOfNumbersDividedByThreeOrFive());

/*
 Problem 2
 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

 By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */
func findSumOfEvenNumbersInFibo() -> Int {
    let upperBound = 4_000_000;
    var current = 2;
    var pre = 0;
    var sumOfEvenNumbers = 0;
    while current < upperBound {
        sumOfEvenNumbers = sumOfEvenNumbers + current;
        (current, pre) = (current * 4 +  pre, current);
       
    }
    return sumOfEvenNumbers;
}
print("\nDay 2 - Q2")
print(findSumOfEvenNumbersInFibo())

/*
 Problem 3
 The prime factors of 13195 are 5, 7, 13 and 29.

 What is the largest prime factor of the number 600851475143 ?s
 */

func findLargestPrimeFactor() -> Int {
    var number = 600_851_475_143;
    var maxPrime = -1;
    let sequence = stride(from: 3, to:  Int(Double(number).squareRoot()), by: 2);
    for iteratedNumber in sequence {
        while(number % iteratedNumber == 0){
            maxPrime = iteratedNumber;
            number = number/iteratedNumber;
        }
    }
    return maxPrime;
    
}
print("\nDay 2 - Q3")
print(findLargestPrimeFactor())

/*
 A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

 Find the largest palindrome made from the product of two 3-digit numbers.
 */
extension Int {
    func isPalindrome() -> Bool {
        var reversedNumber = 0;
        var remainder = 0;
        var originalNumber = self;
        while(originalNumber != 0){
            remainder = originalNumber % 10;
            reversedNumber = reversedNumber * 10 + remainder;
            originalNumber = originalNumber / 10;
        }
        if(reversedNumber == self){
            return true;
        }
        return false;
    }
}

func findLargestPalindromeFor3Digits() -> Int {
    var candidatePalindromeNumber = 0;
    var maxPalindrome = -1;
    for firstMultiplier in (100...999).reversed(){
        for secondMultiplier in (100...firstMultiplier).reversed(){
            candidatePalindromeNumber = firstMultiplier * secondMultiplier;
            if(candidatePalindromeNumber < maxPalindrome){
                break;
            }
            if(candidatePalindromeNumber.isPalindrome() && candidatePalindromeNumber > maxPalindrome){
                maxPalindrome = candidatePalindromeNumber;
            }
            
        }
    }
    return maxPalindrome;
}
print("\nDay 2 - Q4")
let largestPalindrome = findLargestPalindromeFor3Digits();
print(largestPalindrome);

/*
 Question 5
 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

 What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 */
func greatestCommonDivisor(firstNumber: Int, secondNumber: Int) -> Int{
    if(firstNumber % secondNumber != 0){
        return greatestCommonDivisor(firstNumber: secondNumber, secondNumber: firstNumber % secondNumber)
    }
    return secondNumber;
}
func leastCommonMultiplierFor1toN(upperBound: Int) -> Int{
    let upperBound = 20;
    var lcm = 1;
    for i in 1...upperBound{
        lcm = (lcm * i)/greatestCommonDivisor(firstNumber: lcm, secondNumber: i);
    }
    return lcm;
}
print("\nDay 2 - Q5")
let lcmfor1to20 = leastCommonMultiplierFor1toN(upperBound: 20);
print(lcmfor1to20);






